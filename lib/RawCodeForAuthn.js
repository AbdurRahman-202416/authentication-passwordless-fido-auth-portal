const newFn = () => {
  const publicKey = {
    challenge: Uint8Array.from("random-challenge-string-123", (c) =>
      c.charCodeAt(0)
    ),

    rp: {
      name: "Your App Name",
      id: "localhost",
    },

    user: {
      id: Uint8Array.from("user-id-123", (c) => c.charCodeAt(0)),
      name: "abdur@gmail.com",
      displayName: "Abdur Rahman",
    },

    pubKeyCredParams: [
      { type: "public-key", alg: -7 }, // ES256
      { type: "public-key", alg: -257 }, // RS256
    ],

    authenticatorSelection: {
      authenticatorAttachment: "platform", // built-in (Windows Hello, macOS TouchID)
      residentKey: "required",
      userVerification: "required",
    },

    timeout: 60000,

    attestation: "none",
  };

  navigator.credentials
    .create({ publicKey })
    .then((cred) => {
      return console.log("Credential Created:", cred);
    })
    .catch((err) => {
      console.error("Error:", err);
    });
};

const getFn = (credentialIdBase64, registeredTransports) => {
  // In a real application, the challenge and credential data
  // would be fetched from your server after the user provides their username/email.

  // --- 1. Decode Credential ID from the server ---
  // The credential ID is stored as raw bytes (Uint8Array), but often transmitted
  // to/from the server as Base64URL-encoded strings.
  const decodedId = Uint8Array.from(
    atob(credentialIdBase64 || "Y3JlZGVudGlhbC1pZC1mcm9tLXNlcnZlcg=="),
    (c) => c.charCodeAt(0)
  );

  // --- 2. Define the Relying Party Parameters ---
  const publicKey = {
    // **Challenge:** A new, cryptographically secure random value generated by the server.
    // Replace this placeholder with a fresh challenge from your backend.
    challenge: Uint8Array.from("random-challenge-string-456", (c) =>
      c.charCodeAt(0)
    ),

    // **Relying Party (RP) ID:** Must match the 'id' used during registration.
    rpId: "localhost",

    // **Allow Credentials:** Use the specific ID and transports recorded during 'create'.
    allowCredentials: [
      {
        id: decodedId,
        type: "public-key",
        // **KEY FIX:** Use the specific transports recorded at registration.
        // If the server recorded ["platform"] for this ID, only use ["platform"].
        // This is crucial for guiding the browser/authenticator prompt correctly.
        transports: registeredTransports || ["platform", "usb"],
      },
    ],

    // **User Verification:** Must match what was requested during registration.
    authenticatorSelection: {
      userVerification: "required",
    },

    timeout: 60000,
  };

  // --- 3. Execute the Authentication Request ---
  navigator.credentials
    .get({ publicKey })
    .then((assertion) => {
      console.log("Credential assertion received (Login Success):", assertion);
      // Send the 'assertion' object to the server for verification.
    })
    .catch((err) => {
      console.error("Error during authentication:", err);
    });
};

// --- Example Call (Replace with real server data) ---
// If the credential was registered using a built-in sensor (like Touch ID):
// getFn("credential-id-from-server-base64-string", ["platform"]);

// If the credential was registered using a USB key:
// getFn("credential-id-from-server-base64-string", ["usb", "nfc"]);

// For testing purposes, you might call it like this:
// getFn(
//   "Y3JlZGVudGlhbC1pZC1mcm9tLXNlcnZlcg==", // Example Base64 encoded ID
//   ["platform", "usb", "ble", "nfc"] // Example transports array
// );
